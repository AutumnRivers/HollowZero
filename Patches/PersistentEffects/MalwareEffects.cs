using System;
using System.Collections.Generic;
using System.Linq;

using Hacknet;

using HarmonyLib;

using Pathfinder.Event.Gameplay;

namespace HollowZero
{
    [HarmonyPatch]
    internal class MalwareEffects
    {
        internal static List<MalwaredComputer> AffectedComps = new List<MalwaredComputer>();

        internal const float ENCRYPT_SECONDS = 60.0f;
        internal const float DECRYPT_SECONDS = 90.0f;

        internal static Dictionary<Malware, float> MalwareTimers = new Dictionary<Malware, float>();
        internal static List<string> QueuedMalware = new List<string>();

        private static List<Malware> timerDeletionQueue = new List<Malware>();
        private static Dictionary<Malware, float> timerChangeQueue = new Dictionary<Malware, float>();
        private static Dictionary<Malware, float> timerAddQueue = new Dictionary<Malware, float>();

        internal static void ApplyPersistentMalwareEffects(OSUpdateEvent updateEvent)
        {
            OS os = updateEvent.OS;

            foreach(var timer in timerDeletionQueue)
            {
                MalwareTimers.Remove(timer);
            }
            timerDeletionQueue.Clear();

            foreach(var change in timerChangeQueue)
            {
                MalwareTimers[change.Key] = change.Value;
            }
            timerChangeQueue.Clear();

            foreach(var timer in timerAddQueue)
            {
                MalwareTimers.Add(timer.Key, timer.Value);
            }
            timerAddQueue.Clear();

            foreach(var malware in HollowZeroCore.CollectedMalware.Where(PersistentMalware()))
            {
                malware.PowerAction.Invoke(malware.PowerLevel);
            }

            DecreaseMalwareTimer((float)updateEvent.GameTime.ElapsedGameTime.TotalSeconds);
        }

        private static void DecreaseMalwareTimer(float seconds)
        {
            foreach(var mt in MalwareTimers)
            {
                var timer = MalwareTimers[mt.Key];
                if(timer - seconds <= 0)
                {
                    QueuedMalware.Add(mt.Key.DisplayName);
                    //MalwareTimers[mt.Key] = mt.Key.PowerLevel;
                    ChangeMalwareTimer(mt.Key, mt.Key.PowerLevel);
                } else {
                    //MalwareTimers[mt.Key] -= seconds;
                    ChangeMalwareTimer(mt.Key, mt.Value - seconds);
                }
            }
        }

        public static void RemoveMalwareTimer(string malwareName)
        {
            if(MalwareTimers.Any(FindByName()))
            {
                var key = MalwareTimers.First(FindByName());
                timerDeletionQueue.Add(key.Key);
            }

            if(QueuedMalware.Any(m => m == malwareName))
            {
                QueuedMalware.Remove(malwareName);
            }

            Func<KeyValuePair<Malware,float>, bool> FindByName()
            {
                return m => m.Key.DisplayName == malwareName;
            }
        }

        public static KeyValuePair<Malware,float> GetMalwareTimer(string malwareName)
        {
            Func<KeyValuePair<Malware, float>, bool> FindByName()
            {
                return m => m.Key.DisplayName == malwareName;
            }

            return MalwareTimers.FirstOrDefault(FindByName());
        }

        public static void ChangeMalwareTimer(Malware currentMalware, float newTime)
        {
            if(!timerChangeQueue.Any(c => c.Key == currentMalware))
            {
                timerChangeQueue.Add(currentMalware, newTime);
            }
        }

        public static void AddMalwareTimer(Malware malware, float time)
        {
            if(!timerAddQueue.Any(a => a.Key == malware) && !MalwareTimers.Any(m => m.Key == malware))
            {
                timerAddQueue.Add(malware, time);
            }
        }

        public static bool IsMalwareQueued(string name)
        {
            bool isQueued = QueuedMalware.Any(m => m == name);
            if(isQueued) { QueuedMalware.Remove(name); }
            return isQueued;
        }

        private static Func<Malware, bool> PersistentMalware()
        {
            return x => x.Trigger == Malware.MalwareTrigger.Persistent;
        }

        [HarmonyPostfix]
        [HarmonyPatch(typeof(Computer),nameof(Computer.connect))]
        internal static void ApplyNodeConnectMalwareEffects(Computer __instance, string ipFrom)
        {
            if (ipFrom != OS.currentInstance.thisComputer.ip) return;
            if (!HollowZeroCore.CollectedMalware.Exists(x => x.Trigger == Malware.MalwareTrigger.EnterNode)) return;

            foreach(var malware in HollowZeroCore.CollectedMalware.Where(x => x.Trigger == Malware.MalwareTrigger.EnterNode))
            {
                if(AffectedComps.Any())
                {
                    bool computerWasAlreadyAttacked = AffectedComps.Exists(
                    c => c.CompID == __instance.idName && c.AppliedEffects.Exists(fx => fx == malware.DisplayName));
                    if (computerWasAlreadyAttacked) continue;
                }

                bool computerWasAttackedAtAll = false;
                if (AffectedComps.Any())
                {
                    computerWasAttackedAtAll = AffectedComps.Exists(c => c.CompID == __instance.idName);
                }
                
                if(!computerWasAttackedAtAll)
                {
                    var mComp = new MalwaredComputer(__instance);
                    mComp.AppliedEffects.Add(malware.DisplayName);
                    malware.CompAction.Invoke(__instance);
                }
            }
        }

        // There's not actually any planned malware that does this yet...
        [HarmonyPostfix]
        [HarmonyPatch(typeof(Computer), nameof(Computer.disconnecting))]
        internal static void ApplyNodeDisconnectMalwareEffects() { }
    }

    internal class MalwaredComputer
    {
        internal MalwaredComputer(Computer comp)
        {
            CompID = comp.idName;
        }

        internal string CompID;
        internal List<string> AppliedEffects = new List<string>();
    }
}
