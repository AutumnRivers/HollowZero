using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;

using Hacknet;

using HollowZero.Nodes;
using HollowZero.Executables;

using Pathfinder.Executable;
using Pathfinder.Port;
using HollowZero.Managers;

namespace HollowZero
{
    public class DefaultMalware
    {
        private static readonly List<Malware> malwares = new List<Malware>()
        {
            new Malware()
            {
                DisplayName = "Cryptominer",
                Description = "A persistent mining software runs on your system. You won't see a penny. (-100 Max RAM)",
                PowerLevel = 100,
                Trigger = Malware.MalwareTrigger.Persistent,
                PowerAction = delegate(int _)
                {
                    if(OS.currentInstance.exes.Exists(exe => exe.IdentifierName == "Cryptominer")) return;
                    Cryptominer cryptominer = new Cryptominer();
                    cryptominer.bounds.X = OS.currentInstance.ram.bounds.X;
                    cryptominer.bounds.Width = OS.currentInstance.ram.bounds.Width;
                    OS.currentInstance.AddGameExecutable(cryptominer);
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    if(!OS.currentInstance.exes.Exists(exe => exe.IdentifierName == "Cryptominer")) return;
                    OS.currentInstance.exes.First(exe => exe.IdentifierName == "Cryptominer").isExiting = true;
                }
            },
            new Malware()
            {
                DisplayName = "Adware",
                Description = "Congratulations, You Won ! (Random chance to lose 25 credits every time you trigger an event.)",
                PowerLevel = 25,
                Trigger = Malware.MalwareTrigger.EveryAction,
                PowerAction = delegate(int amount)
                {
                    int rng = Utils.random.Next(0, 100);
                    if(rng < 65) return;

                    PlayerManager.RemovePlayerCredits(amount);
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    return; // This malware doesn't need to do anything...
                }
            },
            new Malware()
            {
                DisplayName = "Spyware",
                Description = "I see you... (Randomly closes a random port on the node you're currently connected to.)",
                PowerLevel = 30,
                Trigger = Malware.MalwareTrigger.Persistent,
                PowerAction = delegate(int _)
                {
                    if(!MalwareEffects.IsMalwareQueued("Spyware")) return;

                    OS os = OS.currentInstance;
                    Computer connected = os.connectedComp;

                    float newTime = Utils.random.Next(20, 45);
                    var timer = MalwareEffects.GetMalwareTimer("Spyware");
                    MalwareEffects.ChangeMalwareTimer(timer.Key, newTime);

                    if(connected.idName == "playerComp") return;
                    var openPorts = connected.GetAllPortStates().Where(p => p.Cracked);
                    connected.closePort(openPorts.GetRandom().Record.Protocol, "SPYWARE");
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    MalwareEffects.RemoveMalwareTimer("Spyware");
                },
                SetTimer = true
            },
            new Malware()
            {
                DisplayName = "Dropper",
                Description = "You don't mind holding onto this, right? (Every node, small chance to gain a random Corruption.)",
                PowerLevel = 15,
                Trigger = Malware.MalwareTrigger.EnterNode,
                CompAction = delegate(Computer _)
                {
                    int rng = Utils.random.Next(0, 100);
                    if(rng >= 15) return;

                    InventoryManager.AddCorruption();
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    return; // This shouldn't need to do anything...
                }
            },
            new Malware()
            {
                DisplayName = "Packet Storm",
                Description = "Why's everything... so... slow...? (Prolongs proxy times by 20%)",
                PowerLevel = 20,
                Trigger = Malware.MalwareTrigger.EnterNode,
                CompAction = delegate(Computer target)
                {
                    float multiplier = 20f / 100f;

                    if(!target.hasProxy) return;

                    if(MalwareEffects.AffectedComps.Any(c => c.CompID == target.idName))
                    {
                        var mComp = MalwareEffects.AffectedComps.First(c => c.CompID == target.idName);
                        if(mComp.AppliedEffects.Contains("prolongproxy_20")) return;
                        int index = MalwareEffects.AffectedComps.IndexOf(mComp);
                        mComp.AppliedEffects.Add("prolongproxy_20");
                        MalwareEffects.AffectedComps[index] = mComp;
                        return;
                    }
                    MalwaredComputer malwaredComputer = new MalwaredComputer(target);
                    malwaredComputer.AppliedEffects.Add("prolongproxy_20");

                    int onNetmap = OS.currentInstance.netMap.nodes.IndexOf(target);
                    float baseTime = OS.currentInstance.netMap.nodes[onNetmap].startingOverloadTicks;
                    OS.currentInstance.netMap.nodes[onNetmap].addProxy(baseTime * multiplier);
                },
                RemoveAction = delegate(int m, List<Computer> affectedComps)
                {
                    float multiplier = 20f / 100f;
                    foreach(var comp in affectedComps)
                    {
                        int onNetmap = OS.currentInstance.netMap.nodes.IndexOf(comp);
                        float baseTime = OS.currentInstance.netMap.nodes[onNetmap].startingOverloadTicks;
                        OS.currentInstance.netMap.nodes[onNetmap].addProxy(baseTime / multiplier);
                    }
                }
            },
            new Malware()
            {
                DisplayName = "Skimmer",
                Description = "Just a little off the top. (Shop items are now 10% more expensive)",
                PowerLevel = 10,
                Trigger = Malware.MalwareTrigger.OneShot,
                PowerAction = delegate(int mult)
                {
                    Daemons.Shop.ShopDaemon.PriceMultiplier += 0.1f;
                },
                RemoveAction = delegate(int m, List<Computer> c)
                {
                    Daemons.Shop.ShopDaemon.PriceMultiplier -= 0.1f;
                }
            },
            new Malware()
            {
                DisplayName = "Paranoia",
                Description = "Anything that can go wrong, will go wrong. (Rest Stops now reduce less infection)",
                PowerLevel = 15,
                Trigger = Malware.MalwareTrigger.OneShot,
                PowerAction = delegate(int _)
                {
                    Daemons.RestStopDaemon.ReduceInfectionBy -= 15;
                },
                RemoveAction = delegate(int m, List<Computer> c)
                {
                    Daemons.RestStopDaemon.ReduceInfectionBy += 15;
                }
            },
            new Malware()
            {
                DisplayName = "FireScramble",
                Description = "The numbers, Mason! What do they mean!? (Every node from the next layer onward has a randomly generated firewall.)",
                PowerLevel = 0,
                Trigger = Malware.MalwareTrigger.OnNodeGeneration,
                CompAction = delegate(Computer comp)
                {
                    comp.firewall = new Firewall(Utils.random.Next(3,8));
                },
                RemoveAction = delegate(int m, List<Computer> c)
                {
                    // Doesn't need to do anything...
                }
            }
        };

        public static ReadOnlyCollection<Malware> MalwareCollection = new ReadOnlyCollection<Malware>(malwares);
    }
}
