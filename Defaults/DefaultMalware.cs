using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;

using Hacknet;

using HollowZero.Nodes;
using HollowZero.Executables;

using Pathfinder.Executable;
using Pathfinder.Port;

namespace HollowZero
{
    public class DefaultMalware
    {
        private static readonly Computer AttackerComp = NodeGenerator.GenerateAndAddComputer("Attacker Node");

        private static readonly List<Malware> malwares = new List<Malware>()
        {
            new Malware()
            {
                DisplayName = "Cryptominer",
                Description = "A persistent mining software runs on your system. You won't see a penny. (-100 Max RAM)",
                PowerLevel = 100,
                Trigger = Malware.MalwareTrigger.PERSISTENT,
                PowerAction = delegate(int _)
                {
                    if(OS.currentInstance.exes.Exists(exe => exe.IdentifierName == "Cryptominer")) return;
                    Cryptominer cryptominer = new Cryptominer();
                    cryptominer.bounds.X = OS.currentInstance.ram.bounds.X;
                    cryptominer.bounds.Width = OS.currentInstance.ram.bounds.Width;
                    OS.currentInstance.AddGameExecutable(cryptominer);
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    if(!OS.currentInstance.exes.Exists(exe => exe.IdentifierName == "Cryptominer")) return;
                    OS.currentInstance.exes.First(exe => exe.IdentifierName == "Cryptominer").isExiting = true;
                }
            },
            new Malware()
            {
                DisplayName = "Botnet",
                Description = "Now you've really pissed someone off... (Randomly get attacked by an outside node.)",
                PowerLevel = 300,
                Trigger = Malware.MalwareTrigger.PERSISTENT,
                PowerAction = delegate(int _)
                {
                    if(!MalwareEffects.IsMalwareQueued("Botnet")) return;

                    Random random = new Random();
                    float newTime = random.Next(120, 420);
                    var timer = MalwareEffects.GetMalwareTimer("Botnet");
                    //MalwareEffects.MalwareTimers[timer.Key] = newTime;
                    MalwareEffects.ChangeMalwareTimer(timer.Key, newTime);

                    int rng = random.Next(0, 100);
                    if(rng < 40) return;

                    AttackSequence(AttackerComp);
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    if(HollowTimer.timers.Exists(t => t.Item1 == "malware_attack"))
                    {
                        HollowTimer.timers.RemoveAt(HollowTimer.timers.FindIndex(t => t.Item1 == "malware_attack"));
                    }
                    MalwareEffects.RemoveMalwareTimer("Botnet");
                },
                SetTimer = true
            },
            new Malware()
            {
                DisplayName = "Adware",
                Description = "Congratulations, You Won ! (Random chance to lose 25 credits every time you trigger an event.)",
                PowerLevel = 25,
                Trigger = Malware.MalwareTrigger.EVERY_ACTION,
                PowerAction = delegate(int amount)
                {
                    Random random = new Random();
                    int rng = random.Next(0, 100);
                    if(rng < 65) return;

                    HollowZeroCore.RemovePlayerCredits(amount);
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    return; // This malware doesn't need to do anything...
                }
            },
            new Malware()
            {
                DisplayName = "Spyware",
                Description = "I see you... (Randomly closes a random port on the node you're currently connected to.)",
                PowerLevel = 30,
                Trigger = Malware.MalwareTrigger.PERSISTENT,
                PowerAction = delegate(int _)
                {
                    if(!MalwareEffects.IsMalwareQueued("Spyware")) return;

                    OS os = OS.currentInstance;
                    Computer connected = os.connectedComp;

                    Random random = new Random();
                    float newTime = random.Next(20, 45);
                    var timer = MalwareEffects.GetMalwareTimer("Spyware");
                    //MalwareEffects.MalwareTimers[timer.Key] = newTime;
                    MalwareEffects.ChangeMalwareTimer(timer.Key, newTime);

                    if(connected.idName == "playerComp") return;
                    var openPorts = connected.GetAllPortStates().Where(p => p.Cracked);
                    connected.closePort(openPorts.GetRandom().Record.Protocol, "SPYWARE");
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    MalwareEffects.RemoveMalwareTimer("Spyware");
                },
                SetTimer = true
            },
            new Malware()
            {
                DisplayName = "Dropper",
                Description = "You don't mind holding onto this, right? (Every node, small chance to gain a random Corruption.)",
                PowerLevel = 15,
                Trigger = Malware.MalwareTrigger.ENTER_NODE,
                CompAction = delegate(Computer _)
                {
                    Random random = new Random();
                    int rng = random.Next(0, 100);
                    if(rng <= 15) return;

                    // add code for adding corruptions here...
                },
                RemoveAction = delegate(int _p, List<Computer> _c)
                {
                    return; // This shouldn't need to do anything...
                }
            },
            new Malware()
            {
                DisplayName = "Packet Storm",
                Description = "Why's everything... so... slow...? (Prolongs proxy times by 20%)",
                PowerLevel = 20,
                Trigger = Malware.MalwareTrigger.ENTER_NODE,
                CompAction = delegate(Computer target)
                {
                    float multiplier = 20f / 100f;

                    if(!target.hasProxy) return;

                    if(MalwareEffects.AffectedComps.Any(c => c.CompID == target.idName))
                    {
                        var mComp = MalwareEffects.AffectedComps.First(c => c.CompID == target.idName);
                        if(mComp.AppliedEffects.Contains("prolongproxy_20")) return;
                        int index = MalwareEffects.AffectedComps.IndexOf(mComp);
                        mComp.AppliedEffects.Add("prolongproxy_20");
                        MalwareEffects.AffectedComps[index] = mComp;
                        return;
                    }
                    MalwaredComputer malwaredComputer = new MalwaredComputer(target);
                    malwaredComputer.AppliedEffects.Add("prolongproxy_20");

                    int onNetmap = OS.currentInstance.netMap.nodes.IndexOf(target);
                    float baseTime = OS.currentInstance.netMap.nodes[onNetmap].startingOverloadTicks;
                    OS.currentInstance.netMap.nodes[onNetmap].addProxy(baseTime * multiplier);
                }
            }
        };

        private static void AttackSequence(Computer attacker)
        {
            OS.currentInstance.thisComputer.connect(attacker.ip);

            Action attack = delegate ()
            {
                OS.currentInstance.thisComputer.forkBombClients(attacker.ip);
            };
            var timerTuple = Tuple.Create("malware_attack", 5.3f, attack);
            HollowTimer.timers.Add(timerTuple);
        }

        public static ReadOnlyCollection<Malware> MalwareCollection = new ReadOnlyCollection<Malware>(malwares);
    }
}
